package io.jenkins.plugins.analysis.core.model;

import java.util.Collection;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import edu.hm.hafner.analysis.Issue;

/**
 * A {@link Predicate} that filters {@link Issue} instances by checking their file names against
 * a provided collection of allowed paths.
 *
 * <p>
 * This filter is designed to efficiently handle the intersection between the absolute paths
 * often reported by static analysis tools and the relative paths typically generated by
 * SCM tools (like {@code git diff}). It uses an "ends-with" matching strategy to bridge
 * these differences.
 * </p>
 *
 * @author Your Name
 */
public class FileNameFilter implements Predicate<Issue> {
    /** The set of file paths that are permitted to remain in the report. */
    private final Set<String> allowedFiles;

    /**
     * Creates a new instance of {@link FileNameFilter}.
     *
     * @param fileList
     * the collection of file paths to include in the filter. These are typically
     * retrieved from a version control system's diff output.
     */
    public FileNameFilter(final Collection<String> fileList) {
        this.allowedFiles = fileList.stream().collect(Collectors.toSet());
    }

    /**
     * Evaluates this predicate on the given issue.
     *
     * <p>
     * An issue passes the filter if its file name ends with any of the strings in the
     * allowed files set. This ensures that an issue at {@code /absolute/path/to/src/File.ts}
     * matches an allowed entry of {@code src/File.ts}.
     * </p>
     *
     * @param issue
     * the issue to test.
     * @return {@code true} if the issue's file name is allowed, {@code false} otherwise.
     */
    @Override
    public boolean test(final Issue issue) {
        String fileName = issue.getFileName();

        // Match if the issue's path ends with any file in our diff list.
        // Stream search is used here; for extremely large sets, a suffix-tree
        // approach could be used to further optimize if necessary.
        return allowedFiles.stream().anyMatch(fileName::endsWith);
    }
}
